---- pipe ou pid -1:

EMFILE → o processo já abriu muitos descritores de arquivo (limite atingido).
ENFILE → o sistema inteiro atingiu o limite global de descritores.
EFAULT → o ponteiro passado (pipefd) não aponta para um espaço de memória válido de 2 int.
ENOMEM → memória insuficiente no kernel para alocar estruturas do pipe. (mais raro)




---- Kernel

Ele roda em kernel mode, com acesso total ao hardware (CPU, memória, disco, rede).
Em resumo: o kernel é o “chefe” que organiza quem usa o quê no computador.
		Programas comuns (como o seu pipex) pedem serviços ao kernel.
		O kernel decide se pode ou não atender e depois executa.
Gerencia memória, arquivos, processos, comunicação.
No caso do pipe(), cria um objeto pipe no espaço do kernel + associa 2 números (FDs) ao seu processo.




---- Pipe()

Quando o processo entra no kernel mode pela syscall pipe(), acontece algo assim:

Aloca um objeto pipe no kernel
    O kernel cria uma estrutura interna que representa o pipe (buffer circular).
    Esse buffer geralmente tem 64 KiB por padrão em Linux.

Cria dois descritores de arquivo
    Um para leitura (read end), outro para escrita (write end).
    Eles são adicionados à tabela de descritores de arquivos do processo chamador.
    O kernel procura o próximo número livre (normalmente 3 e 4, porque 0/1/2 já estão ocupados por stdin/out/err).

Escreve esses números em pipe_fd
    pipe_fd[0] recebe o descritor de leitura.
    pipe_fd[1] recebe o descritor de escrita.

Retorna
    Se tudo deu certo: retorna 0.
    Se houve erro (sem memória, muitos descritores abertos etc.): retorna -1 e seta errno.




---- Fork()

Seu processo pede um clone
    Você chama fork().
    A CPU muda para kernel mode.

O kernel cria um novo processo
    Cria uma nova entrada na tabela de processos (task struct).
    Copia o espaço de memória do pai (código, variáveis, pilha, heap).
    Copia os descritores de arquivos abertos (o filho herda todos, inclusive pipes).
    Copia quase todo o estado do pai (registradores, contexto).

Diferença entre pai e filho
    Ambos têm endereço de memória virtual idêntico logo após o fork.
    Mas são processos independentes (PID diferentes).
    A memória não é realmente duplicada no ato — só quando pai/filho escrevem em algo.

Retorno diferente
    Para o pai, fork() retorna o PID do filho.
    Para o filho, fork() retorna 0.